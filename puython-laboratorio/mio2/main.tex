\documentclass{article}
\usepackage[italian]{babel}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}

\section{Analisi dei dati sperimentali: Determinazione di g}

In questo esperimento, determineremo il valore dell'accelerazione di gravità $g$ utilizzando un pendolo semplice. La teoria ci dice che il periodo $T$ di un pendolo semplice è legato alla sua lunghezza $L$ dalla seguente equazione:

\[ T = 2\pi \sqrt{\frac{L}{g}} \]

Elevando al quadrato entrambi i membri, otteniamo:

\[ T^2 = \frac{4\pi^2}{g}L \]

o, ancora,
\[
L=\frac{g T^2}{4 \pi^2 }
\]

Questa è l'equazione di una retta del tipo $y = mx + q$, dove $y = L$, $x = T^2$, $m = \frac{g}{4\pi^2}$ e $q = 0$. Quindi, se plottiamo $L$ in funzione di $T^2$, dovremmo ottenere una retta la cui pendenza $m$ è legata a $g$ dalla relazione:

\[ g = 4\pi^2m \]

Utilizzeremo Python per analizzare i dati sperimentali e determinare $g$. Ecco il codice commentato:

\begin{lstlisting}[language=Python]
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# Dati sperimentali
L = np.array([0.15, 0.2, 0.25, 0.3, 0.34, 0.4, 0.45, 0.54, 0.6])
# t_dati sono le misure ripetute della durata di 20 oscillazioni per ogni lunghezza
t_dati = np.array ([[16.8,16.7,  16.7,  16.3 , 16.9],[18.6 , 18.5 , 18.6 , 18.5, 18.7],[20.2 ,20.3 , 20.3 , 20.2, 20.4], [22.6, 22.6,  22.7 , 22.5,  22.8],[23.4 , 23.5 , 23.4 , 23.1 , 23.6],[25.8 ,25.7, 25.8,  25.9, 25.7],[27.9, 28.0, 28.0, 27.8, 27.7],[29.7, 29.7, 29.6,  29.8, 29.7,],[31.4,  31.5 , 31.5,  31.4, 31.3]])
t =  np.mean(t_dati, axis=1) # tempi medi di 20 oscillazioni
T = t/20.0 #periodo calcolato
T2 = T**2 #quadrati dei periodi calcolati
erroriL=np.array([0.001,0.001,0.001,0.001,0.001,0.001,0.001,0.001,0.001]) #errori sulle lunghezze (in metri)
massimi_colonne = np.max(t_dati, axis=1)
minimi_colonne = np.min(t_dati, axis=1)
errorit = np.array((massimi_colonne - minimi_colonne) / 2)  #calcoliamo l'array di errori ottenuti con la semidispersione
erroriT=errorit/20  #l'errore su T propagato
erroriT2=2*T*erroriT #l'errore su T^2 propagato

# Definizione della funzione di regressione lineare
def linear_fit(x, a, pendenza):
    return a + pendenza * x

# Fitting dei dati sperimentali
params, covariance = curve_fit(linear_fit, T2, L)

# Estrazione dei parametri
a, pendenza = params
err_a, err_pendenza = np.sqrt(np.diag(covariance))
err_g =  4 * np.pi**2*err_pendenza

# Calcolo di g
g = 4 * np.pi**2 * pendenza

# Creazione del modello lineare per il grafico
T2_fit = np.linspace(min(T2), max(T2), 100)
L_fit = linear_fit(T2_fit, a, pendenza)

# Creiamo il grafico
larghezza_originale, altezza_originale = plt.gcf().get_size_inches() # dimensioni originali del grafico (piccole)
fattore_di_scala = 2.6 # il fattore di ingrandimento (occorre fare tentativi per trovare quello giusto)
nuova_larghezza = larghezza_originale * fattore_di_scala #nuove dimensioni riscalate
nuova_altezza = altezza_originale * fattore_di_scala
plt.figure(figsize=(nuova_larghezza, nuova_altezza)) #grafico ingrandito
plt.errorbar(T2, L, xerr=erroriT2, yerr=erroriL, fmt='o', markersize=1, label='Dati con errori su x e y', color='black', ecolor='blue')  # barre di errore
plt.plot(T2, pendenza * T2 + a, color='red', linewidth=0.5, label='Retta di regressione')  # retta di regressione
plt.xlabel('T^2 (m^2)') #etichetta asse x
plt.ylabel('L (m)') #etichetta asse y
plt.title('Determinazione sperimentale di g') #titolo del grafico
txt = f'g = {g:.3f} m/s^2\nErrore su g = {err_g:.3f} m/s^2'
plt.text(0.1, 0.85, txt, transform=plt.gca().transAxes, bbox=dict(facecolor='white', alpha=0.5)) #risultato per g in un box informativo
plt.grid(True) #mostriamo la griglia

# Stampa dei risultati
print(f'a = ({a:.4f} \pm {err_a:.4f}) m')
print(f'pendenza = ({pendenza:.4f} \pm {err_pendenza:.4f}) m/s^2')
print(f'g = ({g:.1f} \pm {err_g:.1f}) m/s^2')

# Mostra il grafico
plt.show()
\end{lstlisting}

\section{Spiegazione del codice}

\begin{enumerate}
    \item Importiamo le librerie necessarie: numpy per calcoli numerici, matplotlib per la creazione di grafici e scipy.optimize per il fitting dei dati.
    
    \item Definiamo i dati sperimentali: lunghezze del pendolo e tempi per 20 oscillazioni.
    
    \item Calcoliamo i periodi medi e i loro quadrati.
    
    \item Calcoliamo gli errori sulle misure utilizzando la semidispersione.
    
    \item Definiamo la funzione di regressione lineare.
    
    \item Utilizziamo curve\_fit per trovare i parametri della retta di best fit.
    
    \item Estraiamo i parametri e calcoliamo $g$ e il suo errore.
    
    \item Creiamo il grafico con i dati sperimentali, le barre di errore e la retta di regressione.
    
    \item Stampiamo i risultati.
\end{enumerate}

Questo codice permette di analizzare i dati sperimentali in modo efficiente, fornendo una stima di $g$ con il relativo errore e una rappresentazione grafica dei risultati.

\end{document}